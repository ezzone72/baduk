<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ë‚´ ì†ì•ˆì˜ ë°”ë‘‘íŒ</title>
  <style>
    :root{ --bg:#0b0f14; --panel:#111826; --wood:#c49a6c; --wood2:#b78957; --text:#e7eefc; --accent:#facc15; --radius: 18px; }
    body{ margin:0; font-family: sans-serif; background: var(--bg); color: var(--text); display: flex; flex-direction: column; align-items: center; }
    #introLayer { position: fixed; top:0; left:0; width:100%; height:100%; z-index: 100; background: #000 url('intro-gpt1.png') no-repeat center center / cover; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; padding-bottom: 100px; transition: 0.5s; }
    .start-btn { padding: 18px 50px; font-size: 1.3rem; font-weight: 800; border-radius: 40px; background: #fff; color: #000; border: none; cursor: pointer; }
    .game-section { width: 100%; max-width: 600px; display: flex; flex-direction: column; align-items: center; padding: 20px; }
    #status { margin-bottom:15px; font-weight: bold; color: var(--accent); }
    .board-container{ position:relative; width:92vw; height:92vw; max-width:550px; max-height:550px; background: var(--wood); border-radius: 8px; border: 4px solid var(--wood2); display:flex; align-items:center; justify-content:center; }
    canvas{ width:100%; height:100%; touch-action:none; cursor: pointer; }
    .btn-group{ width:100%; display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:20px; }
    .btn{ border:none; border-radius:12px; padding:15px; color:#fff; background:#1e293b; font-weight:600; cursor:pointer; }
    .btn-reset { grid-column: span 2; background:#ef4444; }
  </style>
</head>
<body>

<div id="introLayer">
  <button class="start-btn" onclick="startGame()">ìˆ˜ë‹´(æ‰‹è«‡) ì‹œì‘í•˜ê¸°</button>
</div>

<div class="game-section">
  <h1>ë‚´ ì†ì•ˆì˜ ë°”ë‘‘íŒ</h1>
  <div id="status">í‘ì˜ ì°¨ë¡€ (ë°”ë‘‘) | ì¡ì€ ëŒ - í‘: 0 ë°±: 0</div>
  <div class="board-container">
    <canvas id="goBoard"></canvas>
  </div>
  <div class="btn-group">
    <button onclick="toggleMode()" class="btn" id="modeBtn">ğŸ” ì˜¤ëª© ëª¨ë“œë¡œ ì „í™˜</button>
    <button onclick="undo()" class="btn">í•œ ìˆ˜ ë¬´ë¥´ê¸°</button>
    <button onclick="resetBoard()" class="btn btn-reset">íŒ ë¹„ìš°ê¸° (ìƒˆ ê²Œì„)</button>
  </div>
</div>

<script>
  const canvas = document.getElementById('goBoard');
  const ctx = canvas.getContext('2d');
  const SIZE = 19;

  let board = Array.from({length:SIZE}, () => Array(SIZE).fill(0));
  let turn = 1;
  let history = [];
  let isOmok = false;
  let captures = { 1: 0, 2: 0 }; // 1: í‘ì´ ì¡ì€ ìˆ˜, 2: ë°±ì´ ì¡ì€ ìˆ˜

  function startGame() {
    const layer = document.getElementById('introLayer');
    layer.style.opacity = '0';
    setTimeout(() => {
      layer.style.display = 'none';
      initBoard();       // ì‹œì‘ ë²„íŠ¼ì—ì„œë„ ì´ˆê¸°í™”
      updateStatus();
      syncModeButton();
    }, 500);
  }

  // âœ… DPR ìŠ¤ì¼€ì¼ ëˆ„ì  ë°©ì§€: initBoard() ì—¬ëŸ¬ ë²ˆ í˜¸ì¶œë¼ë„ ì•ˆì „
  function initBoard() {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;

    canvas.width  = rect.width * dpr;
    canvas.height = rect.width * dpr;

    // ëˆ„ì  ìŠ¤ì¼€ì¼ ë°©ì§€(ë¦¬ì…‹ í›„ ì¬ì„¤ì •)
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    draw();
  }

  function draw() {
    const s = canvas.width / (window.devicePixelRatio || 1);
    const padding = s / (SIZE + 1);
    const spacing = (s - padding * 2) / (SIZE - 1);

    ctx.clearRect(0, 0, s, s);
    ctx.beginPath();
    ctx.strokeStyle = "#333";

    for (let i = 0; i < SIZE; i++) {
      ctx.moveTo(padding, padding + i * spacing);
      ctx.lineTo(s - padding, padding + i * spacing);

      ctx.moveTo(padding + i * spacing, padding);
      ctx.lineTo(padding + i * spacing, s - padding);
    }
    ctx.stroke();

    for (let y = 0; y < SIZE; y++) {
      for (let x = 0; x < SIZE; x++) {
        if (board[y][x] !== 0) {
          ctx.beginPath();
          ctx.arc(padding + x * spacing, padding + y * spacing, spacing * 0.43, 0, Math.PI * 2);
          ctx.fillStyle = board[y][x] === 1 ? "#000" : "#fff";
          ctx.fill();
        }
      }
    }
  }

  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const s = rect.width;
    const padding = s / (SIZE + 1);
    const spacing = (s - padding * 2) / (SIZE - 1);
    const x = Math.round((e.clientX - rect.left - padding) / spacing);
    const y = Math.round((e.clientY - rect.top - padding) / spacing);

    if (x >= 0 && x < SIZE && y >= 0 && y < SIZE && board[y][x] === 0) {
      let tempBoard = board.map(row => [...row]);
      board[y][x] = turn;

      if (!isOmok) {
        let captured = checkCaptures(x, y, turn);
        if (captured.length === 0 && isSuicide(x, y, turn)) {
          board = tempBoard;
          alert("ìì‚´ìˆ˜ì…ë‹ˆë‹¤!");
          return;
        }
        captured.forEach(p => {
          board[p.y][p.x] = 0;
          captures[turn]++;
        });
      }

      history.push({board: tempBoard, turn, captures: {...captures}});
      if (isOmok && checkOmok(x, y, turn)) {
        draw();
        setTimeout(() => alert("ì˜¤ëª© ìŠ¹ë¦¬!"), 10);
      }

      turn = (turn === 1) ? 2 : 1;
      updateStatus();
      draw();
    }
  });

  function getGroup(x, y, color) {
    let group = [];
    let stack = [{x, y}];
    let visited = new Set();

    while (stack.length > 0) {
      let p = stack.pop();
      let key = p.x + ',' + p.y;
      if (visited.has(key)) continue;

      visited.add(key);
      group.push(p);

      [[1,0],[-1,0],[0,1],[0,-1]].forEach(d => {
        let nx = p.x + d[0], ny = p.y + d[1];
        if (nx>=0 && nx<SIZE && ny>=0 && ny<SIZE && board[ny][nx] === color) {
          stack.push({x:nx, y:ny});
        }
      });
    }
    return group;
  }

  function hasLiberties(group) {
    for (let p of group) {
      let libs = [[1,0],[-1,0],[0,1],[0,-1]];
      for (let d of libs) {
        let nx = p.x + d[0], ny = p.y + d[1];
        if (nx>=0 && nx<SIZE && ny>=0 && ny<SIZE && board[ny][nx] === 0) return true;
      }
    }
    return false;
  }

  function checkCaptures(x, y, color) {
    let opponent = color === 1 ? 2 : 1;
    let allCaptured = [];

    [[1,0],[-1,0],[0,1],[0,-1]].forEach(d => {
      let nx = x + d[0], ny = y + d[1];
      if (nx>=0 && nx<SIZE && ny>=0 && ny<SIZE && board[ny][nx] === opponent) {
        let group = getGroup(nx, ny, opponent);
        if (!hasLiberties(group)) allCaptured.push(...group);
      }
    });
    return allCaptured;
  }

  function isSuicide(x, y, color) {
    return !hasLiberties(getGroup(x, y, color));
  }

  function checkOmok(x, y, c) {
    return [[1,0],[0,1],[1,1],[1,-1]].some(d => {
      let cnt = 1;
      for(let i=1; i<5; i++) if(board[y+d[1]*i]?.[x+d[0]*i]===c) cnt++; else break;
      for(let i=1; i<5; i++) if(board[y-d[1]*i]?.[x-d[0]*i]===c) cnt++; else break;
      return cnt >= 5;
    });
  }

  function syncModeButton() {
    document.getElementById('modeBtn').innerText =
      isOmok ? "ğŸ” ë°”ë‘‘ ëª¨ë“œë¡œ ì „í™˜" : "ğŸ” ì˜¤ëª© ëª¨ë“œë¡œ ì „í™˜";
  }

  // âœ… ì˜¤ëª©ì´ë©´ "ì¡ì€ ëŒ" ìˆ¨ê¹€ + ëª¨ë“œ í‘œì‹œ
  function updateStatus() {
    const modeText = isOmok ? "ì˜¤ëª©" : "ë°”ë‘‘";
    const turnText = `${turn===1?'í‘':'ë°±'}ì˜ ì°¨ë¡€ (${modeText})`;

    document.getElementById('status').innerText = isOmok
      ? turnText
      : `${turnText} | ì¡ì€ ëŒ - í‘: ${captures[1]} ë°±: ${captures[2]}`;
  }

  // âœ… ëŒì´ ìˆëŠ” ìƒíƒœì—ì„œëŠ” ëª¨ë“œ ì „í™˜ ì œí•œ(í•„ìš” ì‹œ íŒ ë¹„ìš°ê³  ì „í™˜)
  function boardNotEmpty() {
    return history.length > 0 || board.some(row => row.some(v => v !== 0));
  }

  function clearBoardSilently() {
    board = Array.from({length:SIZE}, () => Array(SIZE).fill(0));
    captures = {1:0, 2:0};
    history = [];
    turn = 1;
  }

  function toggleMode() {
    if (boardNotEmpty()) {
      const ok = confirm("ëŒì´ ë†“ì—¬ ìˆëŠ” ìƒíƒœì—ì„œëŠ” ëª¨ë“œ ì „í™˜ì´ ë¶ˆê°€í•©ë‹ˆë‹¤.\níŒì„ ë¹„ìš°ê³  ì „í™˜í• ê¹Œìš”?");
      if (!ok) return;
      clearBoardSilently();
    }

    isOmok = !isOmok;
    updateStatus();
    syncModeButton();
    draw();
  }

  function undo() {
    if (history.length > 0) {
      let last = history.pop();
      board = last.board;
      turn = last.turn;
      captures = last.captures;
      updateStatus();
      draw();
    }
  }

  function resetBoard() {
    if (confirm("ì´ˆê¸°í™”?")) {
      clearBoardSilently();
      updateStatus();
      draw();
    }
  }

  // í˜ì´ì§€ ë¡œë“œ ì‹œì—ë„ ì´ˆê¸° ë Œë”(ì¸íŠ¸ë¡œ ë’¤ì— ë¯¸ë¦¬ ê¹”ë¦¼)
  window.onload = () => {
    initBoard();
    updateStatus();
    syncModeButton();
  };
</script>
</body>
</html>
